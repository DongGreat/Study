공부의 기본 = 용어를 알아야 한다
전공자와 비전공자이 차이는 용어의 정의를 아는 것

알고리즘(algorithm)
- (체계적인, 명확한, 유효한)문제 해결 방법
- 해결해야 할 어떤 문제가 주어졌을 때, 이 문제의 해답을 구하기 위한 절차를 순서대로 명확하게 나타낸 것

1) 시간이 적게 걸리지만 메모리를 많이 씀
a = 3, b = 5;
C언어
c = a;
a = b;
b = c;
파이썬
a, b = b, a

2) 메모리를 적게 쓰지만 시간이 많이 걸림
a = a+b;
b = a-b;
a = a-b;

알고리즘의 정의
주어진 문제를 해결하기 위한 단계적인 절차
- 문제 해결 절차를 나타내는 명령어의 집합

알고리즘의 조건
- 입력(well-defined inputs): 알고리즘이 입력을 받는다면 모호하지 않고 잘 정의된 입력이어야 한다. 알고리즘은 0개 이상의 입력을 갖는다.
- 출력(well-defined outputs): 출력은 명확하게 정의되어야 하며 1개 이상의 출력이 반드시 존재하여야 한다.
- 명확성(clear and unambiguous): 각 명령어의 의미는 모호하지 않고 명확해야 한다.
- 유한성(Finite-ness): 한정된 수의 단계 후에는 반드시 종료되어야 한다. 즉, 무한루프나 이와 유사한 상태로 끝나서는 안 된다.
- 유효성(Feasible): 명령어들을 현재 실행 가능한 연산이어야 한다. 미래에 개발될 기술 등을 포함해서는 안 된다.

알고리즘의 기술(description)): 자연어, 흐름도
(1) 영어나 한국어와 같은 자연어를 사용하는 방법
find_max(A)
1. 리스트 A의 첫 번째 항목을 변수 max에 복사(대입)한다.
2. 리스트 A의 다음 항목들을 차례대로 max와 비교(if)하여, max보다 더 크면 그 값을 max로 복사한다.
3. 배열 A의 모든 요소를 비교했으면 max를 반환(return)한다.
(2) 흐름도(flowchart)로 표시하는 방법: 알아보기가 힘들어서 좋은 방법은 아님
(3) 유사 코드(pseudo-code)로 기술하는 방법
find_max(A)
	max <- A[0]	// <-는 대입 연산을 의미함
	for i<-1 to size(A) do
		if A[i]>max then
			max<-A[i]
	return max
(4) 특정한 프로그래밍 언어(예: C언어)
int find_max(int A[], int n) {
	int i, tmp=A[0];
	for(i=1; i<n; i++) {
		if(A[i] > tmp) {
			tmp = A[i];
		}
	}
	return tmp;
}

알고리즘의 기술: 파이썬
- 유사 코드 표현과 매우 유사함
def find_max(A):
	max = A[0]
	for i in range(len(A)):
		if A[i] > max:
			max = A[i]
	return max

array = [1, 5, 2, 3, 4]
print(array, "최댓값 = ", find_max(array))

유클리드 알고리즘
def gcd(a, b):
	while b != 0:
		r = a%b
		a = b
		b = r
	return a

문제의 이해
* 문제를 정확히 이해하는 것이 가장 중요
* 올바른 알고리즘은 "대부분의 입력"이 아니라 "모든 유효한 입력"에 대해 정확한 해답을 구함

개발 방향 결정과 알고리즘의 설계
* 알고리즘 설계 전 결정해야 할 사항들
- 순서적(sequential) 알고리즘 / 병렬처리(parallel) 알고리즘
- 최적해와 근사해
* 근사 알고리즘(10장)을 고려해야 하는 상황
- 많은 사례에 대해 정확한 해를 구할 수 없는 경우: 2의 제곱근 등
- 계산량이 너무 많아 현실적인 시간이 불가능한 경우: 10장
- 알고리즘의 중간 단계에서 사용되는 경우: 9장의 분기 한정 등

알고리즘의 설계 기법들
- 억지(brute-force) 기법과 완전 탐색: 3장
- 축소 정복(decrease-and-conquer): 4장
- 분할 정복(divide-and-conquer): 5장
- 공간을 이용해 시간을 버는 전략: 6장
- 동적 계획법(dynamic programming): 7장
- 탐욕적(greedy) 기법: 8장
- 백트래킹과 분기 한정 기법: 9장

알고리즘의 정확성
* 실험적 분석(Experimental analysis, testing)
- 다양한 입력 적용
- 충분한 테스트가 어느 정도인지 애매함
- 알고리즘이 틀렸다는 것을 보여주기 위해서는 한 가지 입력 사례만으로 충분
* 증명적인 분석(Formal analysis, proving): 보통 이걸 씀
- 수학적인 증명
- 수학적 귀납법(mathematical induction)등
- 증명이 매우 어려울 수도 있음

알고리즘의 분석과 구현
* 알고리즘의 효율성 분석
- 시간 효율성
- 공간 효율성
- 코드 효율성
* 알고리즘 구현
- 특정 프로그래밍 언어
- 컴파일 / 인터프리터

중요한 문제의 유형들
* 정렬(3~6장)
- 데이터를 순서대로 재배열하는 작업
- 오름차순 / 내림차순
- 레코드, 정렬 키(key)
- 비교기반 / 분배기반
- 안정성 만족 / 불만족
- 제자리 정렬
* 탐색
- 원하는 값을 가진 레코드를 찾는 작업
- 탐색키
- 순차 탐색(3장), 이진 탐색(4장), 해싱(6장)
* 문자열 처리
- 문자열(string)은 문자들의 시퀀스(sequence)
- 텍스트 문자열 / 비트 문자열(bit string) / 유전 시퀀스 등
- 문자열 매칭(string matching) 문제: 3장, 6장
* 그래프 문제
- 연결된 객체들 사이의 관계를 표현할 수 있는 자료구조
- 다양한 객체(정점)들이 서로 복잡하게 연결(간선)된 구조 표현
- 다양한 문제들
> 순회(3장)
> 위상 정렬(4장)
> 최단경로(7, 8장)
> 최소비용의 신장트리(8장)
> TSP, Graph Coloring(9장) 등
* 조합 문제(Combinatorial problems)
- 어떤 조건을 만족하는 순열이나 조합 또는 부분 집합과 같은 조합 객체(combinatorial object)를 찾는 문제
- 예: TSP 문제
> 모든 가능한 경로(조합 객체) 중에서 최단 경로란 추가적인 특성을 갖는 조합 객체를 찾는 문제
- 보통 조합 객체의 수가 문제의 크기에 따라 매우 빠르게 증가
- 컴퓨팅에서 가장 어려운 문제: 10장
* 기하학적 문제
- 고대의 그리스인들: 자와 캠퍼스
- 최근접 쌍의 거리 문제(closest-pair problem): 3장, 5장
- 컨벡스 헐(convex-hull)
- 계산 기하학

기본적인 자료구조와 파이썬
* 자료구조
- 자료들을 정리하고 조직화하는 여러가지 구조
- 알고리즘의 설계에 큰 영향을 미침
- 단순 자료구조 / 복합 자료구조
* 배열 구조와 연결된 구조
- 직접 접근 / 순서 접근
- 파이썬에서의 배열: 리스트(list)와 튜플(tuple)로 구현 가능

리스트
* 항목들이 순서대로 나열, 각 항목들은 위치를 갖음
* 파이썬에서 자료구조 "리스트"가 필요하면
- 파이썬의 리스트를 사용
- 파이썬 리스트
> 자료구조 리스트를 배열 구조로 표현한 클래스
> 가장 많이 사용됨

스택
* 후입선출(LIFO: Last-In First-Out)
* 파이썬에서 스택이 필요하면
- 방법 1: 파이썬 리스트 이용
- 방법 2: 큐 모듈(queue)의 LifoQueue 클래스 사용
- 방법 3: 직접 클래스로 구현해서 사용

큐
* 선입선출(FIFO: First-In First-Out)
* 파이썬에서 큐가 필요하면
- 방법 1: 큐 모듈(queue)의 Queue 클래스 사용
- 방법 2: 직접 클래스로 구현해서 사용

우선순위 큐(priority)
* 우선순위의 개념을 큐에 도입한 자료구조
- 선형 자료구조가 아님
- 힙(heap)이 가장 효율적인 구현 방법
* 파이썬에서 우선수위 큐가 필요하면
- heapq 모듈을 사용

그래프: V, E의 집합(V = Vertex, E = Edge)
* G = (V, E)
- V: 정점. 객체(object)를 표현
- E: 간선. 객체들 사이의 관계
* 그래프의 종류
- 방향 그래프
- 무방향 그래프
- 가중치 그래프

트리: 특수한 그래프(사이클이 없는)
* 자유트리(free tree)
- 사이클이 없는 연결 그래프(connected acylic graph)
* 루트를 가진(rooted) 트리
- 자유트리의 정점들 중에 하나를 루트(root)로 선택

집합
* 원소들 사이에 순서가 없고, 중복을 허용하지 않음
- 선형 자료구조가 아님
- "위치"가 없음
* 파이썬의 집합
s1 = {1, 2, 3}
s2 = {2, 3, 4, 5}
s3 = s1.union(s2) # 합집합
s4 = s1.intersection(s2) # 교집합
s5 = s1 - s2 # 차집합

맵 또는 딕셔너리
* 탐색을 위한 자료구조
* 키를 가진 레코드 또는 엔트리(entry)의 집합
* 엔트리
- 키(key): 영어 단어와 같은 레코드를 구분할 수 있는 탐색키
- 값(value): 영어 단어의 의미와 같이 탐색키와 관련된 정보들
* 파이썬의 딕셔너리
colorTable = {'red': (255, 0, 0), 'green': (0, 255, 0), 'red': (0, 0, 255)}
